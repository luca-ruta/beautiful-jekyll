---
layout: post
title: Luca's First Art of Data Lab!
subtitle: What did he do, may you ask?
gh-repo: daattali/beautiful-jekyll
gh-badge: [star, fork, follow]
tags: [test]
comments: true
---

{: .box-success}
## **My answers for 1-3!**
1. The average speed of all the digimon is 120.401606426
2. For “Type”, “Vaccine”: 70
3. ['Koromon', 'Tsunomon', 'Tsumemon'] is a team of three digimon which has <=15 memory and >=300 attack.
## **The work process for my methods (for each question, 1, 2 and 3.**
1. The first method to find the average attack was the easiest by far, and I really did not run into any hiccups as I was writing my code. The key (or rather keys) to my code were the built-in list functions sum() and len(). Knowing I could use these, I put all of the digimon speeds into a single list so I could do sum()/len() which would return the average value of the numbers in the list.
2. When I first approached this method, I was sure my code worked yet it was still giving me an error I had never seen. At this point in my coding process, I had accessed the csv as a nested dictionary using “with open()” outside of any of my methods, and because the first method iterated through the csv as such, when I was doing the same in my second method, the program was unable to iterate through it again. Thus, I had to recode my first and second methods such that I accessed the csv as a nested dictionary within the method so that I would not run into this problem. I would say this taught me a bit more about the limitations of csvs, as well as the limitations of python with csvs. In the end, my code essentially took two parameters which would be what the desired variable was and what the desired variable value was and check if they were the same for each individual digimon. If they were, our variable “count” would be increased by 1, and then the method would return “count” at the end.
3. The third and final method confused me a bit at first. I knew it was not very difficult to look through the csv and find a group of three digimon that would meet the criteria, but that would be too simple. Ultimately, I decided to cheaply find three digimon which had less than five memory and over 100 attack so that any three digimon who fell in this category would make a team that met the criteria. However, the first issue I encountered was that my method would return a list of all of the digimon who fell into the <5 memory and >100 attack, not just a team of three. In order to cut this list down to just three, I tried placing a while loop in the for loop such that the length of the list would not exceed three, meaning the method would return three digimon. However, I was unable to make this work because the while loop was not placed correctly and kept returning the list containing all the <5 memory >100 attack digimon. Instead, I opted to take this list and make a while loop at the end of the method which would pop digimon until the list was at a length of three. This worked, and I successfully completed the task. However, I decided that a more interesting, and probably more adequate solution to this puzzle would be to find every possible team of three digimon that met the <15 memory >300 attack criteria. First, I used nested for loops to make every combination of three digimon, including teams where there were identical digimon. Then, I used a for loop to go through these teams and remove and lists where there were duplicates. This left me with a list of every possible digimon team, and so all I had to do was make one more for loop which could look through the teams and sum their memory and attack to make sure they met the criteria. If I had more time, I would have taken this last step, and ultimately the method would have returned every team of three digimon which had <15 memory >300 attack.
